Cycle Canceling (CC) Algorithm
The Cycle Canceling algorithm is fundamentally different. It first finds any maximum flow (using a standard Max-Flow algorithm), and then iteratively adjusts the flow to reduce the cost without changing the total flow magnitude.
Core Idea: Start with a Max Flow (regardless of cost) and look for negative-cost cycles in the residual graph. If you find one, rerouting flow around it will decrease the total cost without affecting the max flow, moving the solution toward optimality.
How It Works:
Initial Max Flow: First, compute a Max Flow from s to t using any Max-Flow algorithm (e.g., Edmonds-Karp). The resulting cost is likely high, but the flow is maximized.
Negative Cycle Search: In the residual graph, search for a negative cost cycle. This typically requires an algorithm like Bellman-Ford, which can detect negative cycles.
Cancellation (Augmentation): If a negative cycle is found:
Determine the maximum flow that can be pushed around the cycle (limited by the residual capacity of the cycle's bottleneck edge).
Augment this flow along the cycle.
The total Max Flow remains unchanged, but the total cost is reduced by (Flow Amount Ã— Absolute Value of Cycle Cost).
Repeat: Go back to Step 2 and continue to search for and cancel negative cycles until no negative cost cycles exist in the residual graph.

Key Characteristic: When there are no negative cycles in the residual graph, the flow is guaranteed to be the minimum cost for that magnitude of flow (due to the Optimality Condition). Since we started with a Max Flow, the result is the Minimum-Cost Max-Flow.
Code ::
import collections

# A simplified SSP implementation using Bellman-Ford for handling potential negative costs
def min_cost_max_flow_ssp(graph, source, sink, capacity_key='capacity', cost_key='cost'):
    """
    Computes Min-Cost Max-Flow using the Successive Shortest Path algorithm (Bellman-Ford variant).
    This handles negative cost edges introduced by the residual graph.
    
    graph: Adjacency list/dict representation: {u: {v: {capacity: C, cost: D}}}
    Returns: (max_flow, min_cost)
    """
    max_flow = 0
    min_cost = 0
    
    # 1. Initialize residual graph (R)
    # The residual graph includes 'residual_capacity' and 'cost' for forward/backward edges
    residual = collections.defaultdict(dict)
    
    for u in graph:
        for v, data in graph[u].items():
            cost = data[cost_key]
            capacity = data[capacity_key]
            
            # Forward edge (u -> v)
            residual[u][v] = {'residual_capacity': capacity, 'cost': cost}
            # Backward edge (v -> u)
            residual[v][u] = {'residual_capacity': 0, 'cost': -cost}

    # Main loop: Find shortest path and augment flow until no path exists
    while True:
        # 2. Find shortest path using Bellman-Ford
        
        # Initialize distances and parent pointers for path reconstruction
        nodes = list(residual.keys())
        V = len(nodes)
        dist = {node: float('inf') for node in nodes}
        parent = {node: None for node in nodes}
        dist[source] = 0
        
        # Bellman-Ford passes (V-1 times)
        for _ in range(V - 1):
            relaxed = False
            for u in nodes:
                # Iterate over neighbors v of u
                for v, data in residual[u].items():
                    if data['residual_capacity'] > 0:
                        new_cost = dist[u] + data['cost']
                        if dist[v] > new_cost:
                            dist[v] = new_cost
                            parent[v] = u
                            relaxed = True
            if not relaxed: # Optimization: stop if no changes were made
                break
        
        # Check for negative cycles reachable from source in the V-th pass (optional, but good practice)
        # Note: A proper MCMF problem should not have negative cycles *reachable from the source* # in the residual graph after initialization. Bellman-Ford primarily serves to handle
        # the negative costs of reverse edges.

        # 3. Check if a path exists from source to sink
        if dist[sink] == float('inf'):
            break

        # 4. Determine the maximum flow augmentation amount (path_flow)
        path_flow = float('inf')
        curr = sink
        while curr != source:
            prev = parent[curr]
            # Bottleneck is the minimum residual capacity on the path
            path_flow = min(path_flow, residual[prev][curr]['residual_capacity'])
            curr = prev

        # 5. Augment flow and update cost
        max_flow += path_flow
        min_cost += path_flow * dist[sink] # dist[sink] is the total cost of the path

        # 6. Update residual graph capacities
        curr = sink
        while curr != source:
            prev = parent[curr]
            
            # Forward edge (along the path): decrease residual capacity
            residual[prev][curr]['residual_capacity'] -= path_flow
            
            # Backward edge (reverse of the path): increase residual capacity
            residual[curr][prev]['residual_capacity'] += path_flow
            
            curr = prev
            
    return max_flow, min_cost

# --- Example Usage ---

# Test Case from our earlier discussion (Multi-Path Choice)
# Path 1 (Cost 2): s-a-t (C: 1)
# Path 2 (Cost 20): s-b-t (C: 10)
# Expected: Flow 1 on Path 1, Flow 10 on Path 2. Total Cost: 2 + 200 = 202
graph_data_1 = {
    's': {'a': {'capacity': 1, 'cost': 1}, 'b': {'capacity': 10, 'cost': 10}},
    'a': {'t': {'capacity': 1, 'cost': 1}},
    'b': {'t': {'capacity': 10, 'cost': 10}}
}
flow_1, cost_1 = min_cost_max_flow_ssp(graph_data_1, 's', 't')
print(f"Test 1 (Multi-Path): Max Flow: {flow_1}, Min Cost: {cost_1}")

# Test Case with Negative Cost Edge (Crucial check for Bellman-Ford)
# Path S-B-A-T (Cost 5) is cheaper than S-A-T (Cost 20)
# Expected: Max Flow: 5, Min Cost: 25
graph_data_2 = {
    's': {'a': {'capacity': 5, 'cost': 10}, 'b': {'capacity': 5, 'cost': 5}},
    'a': {'t': {'capacity': 5, 'cost': 10}},
    'b': {'a': {'capacity': 5, 'cost': -10}} # Negative cost edge!
}
flow_2, cost_2 = min_cost_max_flow_ssp(graph_data_2, 's', 't')
print(f"Test 2 (Negative Cost): Max Flow: {flow_2}, Min Cost: {cost_2}")

#result and T.C , S.C are included in .docx but not in this since it was in tabuler format.

Conclusion:
 For practical, large-scale problems, SSP with Potentials (Dijkstra's) or Scaling Algorithms are overwhelmingly preferred due to their superior polynomial bounds, whereas the generic Cycle Canceling algorithm is often avoided due to its poor worst-case performance.
