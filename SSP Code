Successive Shortest Path (SSP) Algorithm
The SSP algorithm finds the Minimum-Cost Max-Flow by blending the Max-Flow concept (Edmonds-Karp/Dinic) with the Shortest Path problem (Dijkstra/Bellman-Ford).
Core Idea: Repeatedly find the path from the source (s) to the sink (t) that has the lowest total cost per unit of flow, and send flow along it. This ensures that the flow is built up using the cheapest available routes first.
How It Works:
Start: Initialize flow and cost to zero.
Shortest Path Search: In the residual graph, use an appropriate shortest path algorithm (like Bellman-Ford, or Dijkstra's with potentials) to find a path from s to t where the edge weights are the cost of sending one unit of flow.
Augmentation: If a path is found:
Determine the maximum possible flow that can be pushed along this path (limited by the residual capacity of the path's bottleneck edge).
Augment this flow along the path.
Update the total cost by adding (Flow Amount Ã— Path Cost).
Update Residual Graph: For the edges where flow was augmented, decrease the residual capacity of the forward edges and increase the residual capacity of the reverse edges (with negative costs).
Repeat: Go back to Step 2 and continue until no more paths from s to t can be found in the residual graph.
Key Characteristic: SSP guarantees that the final flow is both the maximum possible and is achieved at the minimum possible cost.

Code ::
import collections

# A simplified SSP implementation using Bellman-Ford for handling potential negative costs
def min_cost_max_flow_ssp(graph, source, sink, capacity_key='capacity', cost_key='cost', flow_key='flow'):
    """
    Computes Min-Cost Max-Flow using the Successive Shortest Path algorithm (Bellman-Ford variant).
    graph: Adjacency list/dict representation: {u: {v: {capacity: C, cost: D}}}
    """
    max_flow = 0
    min_cost = 0
    
    # Initialize residual graph (assuming no flow initially)
    # The residual graph includes 'residual_capacity' and 'cost' for forward/backward edges
    residual = collections.defaultdict(dict)
    for u in graph:
        for v, data in graph[u].items():
            residual[u][v] = {'residual_capacity': data[capacity_key], cost_key: data[cost_key], 'reverse': v}
            # Add reverse edge for residual graph
            residual[v][u] = {'residual_capacity': 0, cost_key: -data[cost_key], 'reverse': u}

    while True:
        # 1. Find shortest path using Bellman-Ford (or SPFA for better avg case)
        #   dist: shortest cost from source
        #   parent: stores (u, v) for path reconstruction
        dist = {node: float('inf') for node in residual}
        parent = {node: None for node in residual}
dist[source] = 0
        
        # Bellman-Ford passes (V-1 times)
        V = len(residual)
        for _ in range(V - 1):
            relaxed = False
            for u in residual:
                for v, data in residual[u].items():
                    if data['residual_capacity'] > 0:
                        new_cost = dist[u] + data[cost_key]
                        if dist[v] > new_cost:
                            dist[v] = new_cost
                            parent[v] = u
                            relaxed = True
            if not relaxed: # Optimization
                break
        
        # Check for negative cycles reachable from source - this suggests an error 
        # or the problem has an unbounded solution, but for MCMF it's generally avoided
        # by checking for a relaxation in the V-th pass.
        
        # 2. Check if a path exists
        if dist[sink] == float('inf'):
            break

        # 3. Determine flow augmentation amount
        path_flow = float('inf')
        curr = sink
        while curr != source:
            prev = parent[curr]
            path_flow = min(path_flow, residual[prev][curr]['residual_capacity'])
            curr = prev

 # 4. Augment flow and update cost
        max_flow += path_flow
        min_cost += path_flow * dist[sink]
        
        # 5. Update residual graph
        curr = sink
        while curr != source:
            prev = parent[curr]
            
            # Forward edge: decrease residual capacity
            residual[prev][curr]['residual_capacity'] -= path_flow
            
            # Backward edge (reverse of forward edge): increase residual capacity
            residual[curr][prev]['residual_capacity'] += path_flow
            
            curr = prev
            
    return max_flow, min_cost

# Example usage structure:
# graph_data = {
#     's': {'a': {'capacity': 10, 'cost': 1}, 'c': {'capacity': 5, 'cost': 5}},
#     'a': {'b': {'capacity': 8, 'cost': 2}},
#     'c': {'d': {'capacity': 5, 'cost': 1}},
#     'b': {'t': {'capacity': 10, 'cost': 1}},
#     'd': {'t': {'capacity': 5, 'cost': 1}}
# }
# flow, cost = min_cost_max_flow_ssp(graph_data, 's', 't')
# print(f"Max Flow: {flow}, Min Cost: {cost}")

# Results And TC , SC are included in ,docx not in this since it was in tabuler format .

